## section02

### Page Router

- React Router처럼 페이지 라우팅 기능을 제공함
- pages 폴더를 기반으로 페이지 라우팅을 해줌
- pages 폴더 아래에 js 파일을 두게 되면 자동으로 페이지 경로 만들어줌
- 파일명 기반의 페이지 라우팅
- 폴더명 기반으로도 페이지 라우팅 가능
- 동적경로 갖는 페이지 라우팅도 간단하게 설정 가능
  - 쇼핑몰 상품 상세 페이지 같은 곳에서 자주 사용
    = [id].js 로 만들어주면 동적경로 대응 (대괄호로 묶게 되면 따라서 id에 매핑되는)

<br>

- import alias- 절대 경로로 모듈을 import 할 수 있도록 도와주는 기능

<br>

#### pages 폴더 안에 있는 \_app.tsx와 \_document.tsx

- 페이지의 역할을 하는 파일은 아님
- 공통적으로 적용되는 로직이나 공통적으로 적용되는 레이아웃 또는 데이터를 다루기 위해 필요한 파일
- \_app.tsx도 루트 컴포넌트의 역할을 한다고 생각하면 됨

  - 모든 페이지를 하는 컴포넌트들의 부모 컴포넌트
  - Component라는 props는 page 역할을 할 컴포넌트를 받는 것
  - pageProps는 Component에 전달될 props들을 객체로 변환한 것

- \_document.tsx
  - 모든 페이지에 적용되어야하는 html 코드를 설정하는 컴포넌트
  - 리액트 앱의 index.html과 비슷
  - 페이지 전체에 적용되는 html 태그를 다루는 곳

<br>
-쿼리 스트링의 경우 페이지 경로에는 영향 주지 않기 때문에 pages 폴더 아래에 별도의 설정을 해 줄 필요는 없음
-대신 useRouter 사용해 쿼리값 읽어오기 (router.query)

<br>
- url 파라미터(동적 경로)를 사용하기 위해서는 [id] 이용해야함
- url 파라미터 값을 읽어오기 위해서도 useRouter 사용
-[...id]를 사용하면 여러개의 id 사용 가능할 수 있게 됨 => Catch All Segment
-[[...id]]로 만들면 / 에도 대응하는 완전히 범용적인 페이지로 진화 => Optional Catch All Segment

<br>
- 404.tsx 파일 만들면 없는 경로에 대응하는 페이지 만들어줌

### 네비게이팅

### 프로그래매틱한 페이지이동(Programmatice Navigation)

- 특정 버튼이 클릭되었거나 특정 조건이 만족되었을 때 함수 내부에서 페이지가 이동되는 것
- router.replace 이용하면 뒤로가기를 방지하며 페이지 이동시킬 수 있음
  -router.back 을 통해 뒤로가기 가능

## 프리페칭

- 프리페칭 = 사전에 미리 불러오는 것
- 페이지를 사전에 불러옴
- 현재 사용자가 보고 있는 페이지에서 연결된 모든 페이지들을 사전에 미리 불러와놓음
- 이동할 가능성 있는 기능을 모두 불러놓는 것!
  => 빠른 페이지 이동을 위해 제공되는 기능

- 넥스트는 작성한 모든 리액트 컴포넌트를 페이지 별로 분리해서 저장을 미리 해둠
- 사전 렌더링 과정에서 js 번들 파일 전달할때 현재 페이지에 해당하는 코드들만 전달이 됨!!
  => 모든 페이지에 해당하는 js 코드들을 매번 번들링해서 전달하면 파일의 용량이 너무 커지게 되므로 hydration이 느려짐

- 다시 페이지를 이동하려고 하면 이동하려고 하는 페이지의 js 코드를 추가로 불러와야하는 과정이 필요함
  => 페이지 이동이 느려질 수 있음

==>이러한 문제를 방지하기 위해 프리페칭 기능이 필요!

#### 초기 접속 시에 요청 페이지의 JS bundle을 전달 받고 페이지 이동이 일어나기 전에 PreFetching 기능을 이용해 연결된 페이지들을 미리 불러옴

- Link 컴포넌트로 구현된 경로가 아니라면 프리페칭이 일어나지 않음
- 프로그래매틱한 페이지도 프리페칭 시키고 싶다면 useEffect 이용해서 마운트 되었을 때 실행 시키면 됨
- router.prefecth 이용하면 됨

## api routes

- api 폴더 아래 파일 만들게 되면 해당 파일은 웹 페이지가 아닌 api routes로써 api 응답을 정의하는 파일로 설정됨
- api 경로는 폴더 구조에 맞춰 갖게 됨 (/api/~~)

### 데이터 페칭

- 기존의 리액트 방식으로 데이터 페칭을 하면 초기 접속 요청부터 데이터 로딩이 오래 걸림
  => 컴포넌트 마운트 시점에 fetchData 호출하므로

- next는 fcp 문제를 해결하기 위해 사전 렌더링 방식을 이용하기 때문에 완성된 HTML 을 받아서 그대로 렌더링
- 이때 서버측에서 js 코드 실행해서 사전 렌더링을 직접 진행하는 과정에서 백엔드서버에서 현재 필요한 데이터를 미리 불러오도록 설정할 수 있음!
  => 데이터를 빠른 타이밍에 호출 할 수 있음

- 데이터 페칭이 이미 완료된 페이지를 보여주는 것!

- 만약 이때 데이터페칭이 오래걸리는 경우가 생긴다면..?
  => 이러한 문제점을 해결하기 위해 next는 사전 렌더링이 오래 걸릴 것 같은 페이지에 대해서 빌드타임(build time)에 미리 사전 렌더링을 마쳐놓는 등의 다양한 방식을 제공함

## 서버사이드 렌더링 방식

### SSR

- 가장 기본적인 사전 렌더링 방식
- 요청이 들어올 때마다 사전렌더링 진행

### SSG

- 정적 사이트 생성
- 빌드타임에 미리 페이지를 사전렌더링

### ISR

- 증분 정적 재생성

---

## SSR

```javaScript
export const getServerSideProps = () => {};
```

- 이런식으로 약속된 이름의 함수를 써주면 이 함수를 써준 페이지는 ssr로 작동함
- 페이지로 요청 경로가 들어옴 -> 그러면 다음으로 getSeverSideProps 함수 작동 => 백엔드 서버로 데이터 불러온다던가 서드파티로 데이터 불러온다던가 불러옴
  -> 그러고나서 페이지가 렌더링 됨

- 이 함수는 서버측에서 딱 한번만 실행되는 함수임 => 이 함수 내에서 브라우저를 읽을 수 없으므로 window. 이런 거 못함
