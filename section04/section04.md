## 데이터 페칭

- 서버 컴포넌트를 사용하면 async 를 컴포넌트에 붙일 수 있음! => await 붙여서 데이터 불러오기 가능

## 데이터 캐시

- fetch 메서드를 활용해 불러온 데이터를 Next 서버에서 보관하는 기능
- 영구적으로 데이터를 보관하거나 득정시간을 주기로 갱신시키는 것도 가능
- 불필요한 데이터 요청의 수를 줄여서 웹 서비스의 성능을 크게 개선할 수 있음
- fetch 메서드에 두번째 변수로 cache: 인수 추가해서 사용가능
- cache: "force-cache"
  - 요청의 결과를 무조건 캐싱함
  - 한번 호출된 이후에는 다시는 호출되지 않음
  - 접속요청 받으면 넥스트 서버 사전렌더링 진행하는데 데이터 캐시에서 먼저 저장된 데이터를 찾아보고 저장된 데이터가 없으면 MISS 판정나서 일단 백엔드 서버에게 데이터 요청하고 그 데이터를 데이터 캐시 안에 SET 해서 저장, 그 이후 다시 접속 요청 받으면 캐시된 데이터 찾아내게 되고(HIT) 백엔드 서버에게 데이터 받르 필요 없으믈 ㅗ빠르게 HTML 렌더링
- cache: "no-store"
  - 데이터 패칭의 결과를 절대 저장하지 않음
  - 캐싱을 아예 하지 않도록 설정하는 옵션
  - 접속요청 들어오면 넥스트 서버는 사전 렌더링 진행하게 되는데 캐시 옵션이 no-store로 설정되어있으면 캐싱된 데이터 사용하지 않아 데이터 캐시 스킵해 백엔드 서버에서 응답받은 데이터를 사용
  - next 15부터는 옵션 설정하지 않았을 때 기본값
- next:{revalidate:10}
  - 특정시간을 주기로 캐시를 업데이트
  - 마치 Page Router의 ISR 방식
  - 특정시간이 지나고 접속 요청이 들어오면 STALE(상했다는 뜻) 데이터라도 일단 반환하고 서버측에서 다시 데이터 불러와서 SET(Reavalidate Data) 해서 그 다음 요청부터는 다시 최신 데이터 반환해줌
- next:{tags:['a']}
  - On-Demand Revalidate
  - 요청이 들어왔을 때 데이터를 최신화 함

## 리퀘스트 메모이제이션

- 요청을 기억한다
- 중복적으로 발생한 요청들을 캐싱해서 다시 요청하지 않게
- 넥스트 서버에서 리퀘스트 메모이제이션으로 하나의 중복된 요청을 자동으로 캐싱해줌
- 하나의 페이지를 렌더링하는 동안에 중복된 API 요청을 캐싱하기 위해 존재함
- 따라서 렌더링이 종료되면 모든 캐시가 소멸
- 서버 컴포넌트가 도입되어 데이터 페칭 형태가 달라졌기 때문에 메모이제이션 필요
